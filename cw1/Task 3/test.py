from cmath import nan
import numpy as np
from scipy.interpolate import LinearNDInterpolator
import matplotlib.pyplot as plt
# def func(x, y):
#     return x*(1-x)*np.cos(4*np.pi*x) * np.sin(4*np.pi*y**2)**2

    

# grid_x, grid_y = np.mgrid[0:1:100j, 0:1:200j]

# rng = np.random.default_rng()
# points = rng.random((1000, 2))
# values = func(points[:,0], points[:,1])

# from scipy.interpolate import griddata
# grid_z0 = griddata(points, values, (grid_x, grid_y), method='nearest')
# grid_z1 = griddata(points, values, (grid_x, grid_y), method='linear')
# grid_z2 = griddata(points, values, (grid_x, grid_y), method='cubic')




# x = np.linspace(0,Range[0],Range[0]+1)
# y = np.linspace(0,Range[1],Range[1]+1)
# z = np.linspace(0,Range[2],Range[2]+1)
# xg, yg  = np.meshgrid(x, y, indexing='ij', sparse=True)
# self.Result2 = griddata(np.transpose(Result[0:2,:]), Result[3,:], (xg, yg ), method='linear')
# print(' finish Interpolation')
a = nan
b = a + 1
print(b)



